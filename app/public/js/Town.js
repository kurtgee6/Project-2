// -------------------------------------------------------------------------------------------
// INITALIZING GAME STATE 
// -------------------------------------------------------------------------------------------
// setting up rpg canvas by declaring single rpg state with div id='rpg'

var LoM = LoM || {};
var game;
var initialized = false;
var chatActive = false;

LoM.Town = function(){};

LoM.Town = {
    // -------------------------------------------------------------------------------------------
    // INITALIZING GAME STATE
    // -------------------------------------------------------------------------------------------
    // allow Town to run in the background
    init:function(){
        this.stage.disableVisibilityChange = true;
    },

    // -------------------------------------------------------------------------------------------
    // CREATE GAME STATE
    // -------------------------------------------------------------------------------------------    
    create: function(){
        // GAME VIEWS INITIALIZATION
        // -----------------------------------------------------------
        // setting updating frequency to lighten load on socket IO
	    this.time.advancedTiming = true;
        this.time.desiredFps = 40;
        this.time.suggestedFps = 40;
        
        // setting object reference to be used in other functions object
        game = this;

        // event handling boolean
        this.eventActive = {};
        this.eventActive.state = false;

        // object for storing battle info
        this.battleInfo = {}

        // generate data map
        this.groupMap = {}
        this.spriteMap = {}

        // setting a higher hierachy object for userInfo to reference to
        LoM.userInfo = this.userInfo;

        // generate children objects for this.groupMap and this.spriteMap
        // this allow any element generated by the game to be trackable and refer to later
        // look at generator.js for details
        this.genDataMap(['tileMap','layers','collisions','players','npcs','enemies','objects']);
        
        // Generate Layer Collisions
        // -----------------------------------------------------------------------
        
        // set collision events for the game for user interactions with an array of tile index
        this.genLayerCollisions('Houses','wallCollisions',
            [],
            this.wallCollisions
        ); 

        this.genLayerCollisions('Houses','shop',
            [1595],
            this.shopInteractions
        )
        this.genLayerCollisions('Houses','inn',
            [147],
            this.innInteractions
        )

        // generate all online users accessing the game
        // use initial array if playerMaster is empty, else use playerMaster object
        // to generate players
        if(Object.keys(LoM.playerMaster).length > 0){
            for(player in LoM.playerMaster){
                // console.log(player)
                if(LoM.playerMaster[player].world.state === 'Town'){
                    this.addPlayer(LoM.playerMaster[player])
                }
            }
        }
        else{
            // console.log(LoM.playerArray)
            for(i = 0; i < LoM.playerArray.length;i++){
                if(LoM.playerArray[i].world.state === 'Town'){
                    this.addPlayer(LoM.playerArray[i])
                }
            }
        }

        var sprite2Info = {
            id: '2',
            sprite: "sprite3",
            role: 'npc',
            name: 'Mysterious Stranger',
            velocity: {x: -10, y: 0},
            world: {x: 390,y:280,state:'Town'}
        }


        this.addPlayer(sprite2Info, "Town");
        this.sprite2 = this.groupMap.npcs['sample'];

        // after all players is load for the current user, the game start
        // this prevent update from running before all the players is loaded
        
        // ENABLE KEYBOARD INPUT
        // --------------------------------------------------------------
        this.cursor = this.input.keyboard.createCursorKeys();  
        this.input.keyboard.addKey(Phaser.Keyboard.W)
        this.input.keyboard.addKey(Phaser.Keyboard.A)
        this.input.keyboard.addKey(Phaser.Keyboard.S)
        this.input.keyboard.addKey(Phaser.Keyboard.D)

        initialized = true;
    },

    // -------------------------------------------------------------------------------------------
    // UPDATING GAME STATE
    // -------------------------------------------------------------------------------------------    
    update: function(){
        // if all player data is loaded, start the game update
        if(initialized){
            // always listen to building collisions
            this.physics.arcade.collide(this.groupMap.players, this.spriteMap.collisions['wallCollisions'],this.spriteMap.collisions['wallCollisions'].data['onCollide'], null, this);
            
            // update world position 
            var worldX = LoM.spriteMaster[this.userInfo.id].x;
            var worldY = LoM.spriteMaster[this.userInfo.id].y;

            this.checkLayerCollisions();
            //  if no event is active
            if(this.eventActive.state){
                if(!this.lastLocationSaved){
                    LoM.spriteMaster[this.userInfo.id].lastLocation = {
                        x: LoM.spriteMaster[this.userInfo.id].x,
                        y: LoM.spriteMaster[this.userInfo.id].y      
                    } 
                    this.lastLocationSaved = true
                }else{
                    var lastLocation = LoM.spriteMaster[this.userInfo.id].lastLocation
                    var dX = worldX - lastLocation.x;
                    var dY = worldY - lastLocation.y;
                    var distance = Math.sqrt( Math.pow(dX, 2) + Math.pow(dY, 2));
                    if(distance > 20){
                        this.eventActive.state = false;
                        this.eventActive.player = {};
                        this.eventActive.target = {};
                        this.lastLocationSaved = false;
                        console.log('reset event')
                        removeInteractionDisplay()
                    }
                }
            }

            // listen for key press for character movement and pass that information to socket.io
            // if the last key pressed was 100ms ago, then listen stop updating to server 
            if(this.input.keyboard.isDown(Phaser.Keyboard.W)){     
                Client.move({dir:'up', id: LoM.userInfo.id,  worldX: worldX, worldY: worldY, state: 'Town' });
            }else if(this.input.keyboard.isDown(Phaser.Keyboard.S)){;
                Client.move({dir: 'down', id: LoM.userInfo.id, worldX: worldX, worldY: worldY,  state: 'Town'  });
            }else if(this.input.keyboard.isDown(Phaser.Keyboard.A)){
                Client.move({dir:'left', id: LoM.userInfo.id,  worldX: worldX, worldY: worldY,  state: 'Town'  })
            }else if(this.input.keyboard.isDown(Phaser.Keyboard.D)){
                Client.move({dir:'right', id: LoM.userInfo.id,  worldX: worldX, worldY: worldY,  state: 'Town'  })
            }else if(this.input.keyboard.upDuration(65,30)|| this.input.keyboard.upDuration(87,100) || this.input.keyboard.upDuration(83,100) || this.input.keyboard.upDuration(68,100)){
                Client.move({dir:'stationary', id:LoM.userInfo.id, worldX: worldX, worldY: worldY,  state: 'Town' })
            }
        }
    },

    render: function(){
    },

    randomInt: function (low,high){
        return Math.floor(Math.random() * (high - low) + low);
    },

    checkLayerCollisions: function(){
        // listen to player-npc and player-player interactions
        // this.physics.arcade.collide(this.groupMap.players, this.groupMap.players, this.spriteCollisions, null, this);
        this.physics.arcade.collide(this.groupMap.players, this.groupMap.npcs, this.npcInteractions, null, this);
        // listen for collision interactions
        for(var collision in this.spriteMap.collisions){
            this.physics.arcade.collide(LoM.spriteMaster[LoM.userInfo.id], this.spriteMap.collisions[collision], 
                this.spriteMap.collisions[collision].data['onCollide'],null, this);
        }
    }
}





